---
title: 数据结构——线性表
author: DingWH03
hide: false
archive: true
math: true
date: 2024-07-23 08:45:58
tags: [数据结构, 笔记]
categories: 数据结构
---
# 线性表

> 线性结构的特点是：在数据元素的非空有限集中，(1)存在唯一的一个被称做“第一个”的数据元素；(2)存在唯一的一个被称做“最后一个”的数据元素；(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。

## 一、线性表的基本概念

### （一）线性表的定义

线性表是由n个具有相同数据类型的数据元素组成的有限序列。其中n>=0，n为表长，当n为0时线性表是一个空表，若用L命名线性表，则其一般表示为：

<center>L=(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>i</sub>, …, a<sub>n</sub>)</center>

式中，a<sub>1</sub>是唯一的“第一个”数据元素，又称表头元素；a<sub>n</sub>是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外,每个元素有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。

在稍复杂的线性表中，一个数据元素可以由若干个**数据项**(item)组成。在这种情况下，常把数据元素称为**记录**(record)，含有大量记录的线性表又称**文件**(file)。

以上就是线性表的逻辑特性,这种线性有序的逻辑结构正是线性表名字的由来。

由此,我们得出线性表的特点如下:

 - 表中元素的个数有限。
 - 表中元素具有逻辑上的顺序性，表中元素有其先后次序。
 - 表中元素都是数据元素，每个元素都是单个元素。
 - 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
 - 表中元素具有抽象性，即仅讨论元素间的逻辑关系,而不考虑元素究竟表示什么内容。

### （二）线性表的基本操作

抽象数据类型线性表的定义如下：

    ```
    ADT List {
        数据对象：D = { a<sub>i</sub> | a<sub>i</sub> ∈ ElemSet, i = 1,2,…,n, n>=0 }
        数据关系：R1 = ( <a<sub>i-1</sub>, a<sub>i</sub>> | a<sub>i-1</sub>,a<sub>i</sub> ∈ D, i = 2,…,n)
        基本操作：
        InitList( &L )
            操作结果：构造一个空的线性表L。
        DestroyList( &L )
            初始条件：线性表L已存在。
            操作结果：销毁线性表L。
        ClearList( &L )
            初始条件：线性表L已存在。
            操作结果：将L重置为空表。
        PrintList( L )
            初始条件：线性表L已存在。
            操作结果：按前后顺序输出线性表L的所有元素。
        ListEmpty( L )
            初始条件：线性表L已存在。
            操作结果：若L为空表，则返回True，否则返回False。
        Listlength( L )
            初始条件：线性表L已存在。
            操作结果：返回L中数据元素个数。
        GetElem( L, i, &e )
            初始条件：线性表L已存在，1<=i<=ListLength(L)。
            操作结果：用e返回L中第i个数据元素的值。
        LocateElem( L, e, compare() )
            初始条件：线性表L已存在，compare()是数据元素判定函数。
            操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0。
        PriorElem( L, cur_e, &pre_e )
            初始条件：线性表L已存在。
            操作结果：若cur_e是L的数据元素，且不是第一个，则用则用pre_e来返回他的前驱，否则操作失败，pre_e无定义。
        NextElem( L, cur_e, &pre_e )
            初始条件：线性表L已存在。
            操作结果：若cur_e是L的数据元素，且不是最后一个，则用则用next_e来返回他的后继，否则操作失败，next_e无定义。
        ListInsert( &L, i, e )
            初始条件：线性表L已存在，1<=i<=ListLength(L)+1。
            操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。
        ListDelete( &L, i, &e )
            初始条件：线性表L已存在且非空，1<=i<=ListLength(L)。
            操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1。
        ListTraverse( L, visit() )
            初始条件：线性表L已存在。
            操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。
    } ADT List
    ```

除了以上操作，还可以有一些更复杂的操作，例如拆分、合成与复制线性表。

## 二、线性表的实现

### （一）顺序存储

#### 1.顺序表的定义

线性表的顺序存储指的是用一组地址连续的存储单元依次存储线性表的数据元素，又称为顺序表，因此表中逻辑上相邻的两个元素在物理位置上也连续，正因为这一点，而且线性表中各元素属于同一类型，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的数据结构。通常用高级程序设计语言的数组来描述线性表的顺序存储结构。

#### 2.顺序表的实现

在C++语言中，我们可以使用一维数组作为顺序表的存储结构，但是同样是数组我们也有两种不同的实现方式，分别是静态分配与动态分配。对数组进行静态分配时，由于数组的大小和空间已经固定，所以空间一旦被占满，再加入新数据就会发生溢出，进而导致程序崩溃。而进行动态分配则可以避免这一问题，存储数组的空间大小是在程序执行过程中可以自由调整的，通过内存分配语句来进行控制，因此一旦空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到扩充数组存储空间的目的，而不需要一次性地为数组划分所有空间。

> 后续所有代码均采用C++实现，并为了保持跟课本上定义的抽象数据类型的基本操作一致，仅仅会使用部分C++特性。比如这一节我使用类来定义顺序表的数据结构，却将数据操作方法定义在类外，完全可以定义在类内进行，且更推荐将所有相关操作定义在同一类内而不是使用引用的方式。

##### 静态分配

首先来看一下静态分配顺序表的数据结构：

```c++
#define MaxSize 10 // 顺序表的最大长度
class SqList {
public:
    int data[MaxSize]; // 实际的存储结构，采用数组存储
    int length; // 记录顺序表的当前长度

    SqList() {
        length = 0;
        for (int i = 0; i < MaxSize; ++i) {
            data[i] = 0; // 将数组内的每个数值初始化为0,否则访问时为随机值，即脏数据
        }
    }
};
```

可见，在创建`SqList`这个数据结构时已经完成了内存分配，顺序表长度不可改变，并且由于数组可以通过数组下标来访问每个位置的元素，实现了顺序表随机存取的特性。但需要注意C++数组下标从0开始。

下面是函数声明部分，定义了顺序表各个函数，这里不多做解释。

```c++
// 函数声明
void InitList(SqList &L);                           // 初始化
void DestroyList(SqList &L);                        // 销毁
void ClearList(SqList &L);                          // 重置为空表
void PrintList(const SqList &L);                    // 打印
bool ListEmpty(const SqList &L);                    // 判空
int ListLength(const SqList &L);                    // 获取长度
bool GetElem(const SqList &L, int i, int &e);       // 按位查找
int LocateElem(const SqList &L, int e);             // 按值查找
bool PriorElem(const SqList &L, int cur_e, int &pre_e); // 查找前驱
bool NextElem(const SqList &L, int cur_e, int &next_e); // 查找后继
bool ListInsert(SqList &L, int i, int e);           // 插入
bool ListDelete(SqList &L, int i, int &e);          // 删除
void ListTraverse(const SqList &L, void (*visit)(int)); // 遍历
bool LocateChangeElem(SqList &L, int e, int em);    // 先按值查找后改值
bool GetChangeElem(SqList &L, int i, int em);       // 先按位序查找后改值
```

下面是顺序表的初始化，销毁与清空。初始化在新建`SqList`时其实已经发生，而销毁操作会自动进行，因此无需手动销毁，清空操作是将长度置0然后将数组元素全部清空。

```c++
// 实现模块
void InitList(SqList &L) {
    L.length = 0;
}

void DestroyList(SqList &L) {
    // 静态分配，无需显式销毁
}

void ClearList(SqList &L) {
    L.length = 0;
    for (int i = 0; i < MaxSize; ++i) {
        L.data[i] = 0;
    }
}
```

下面是顺序表的打印，即数据表的元素存储在数组的前`length`位置上，只需循环访问即可。

```c++
void PrintList(const SqList &L) {
    std::cout << "开始打印顺序表\n";
    for (int i = 0; i < L.length; ++i) {
        std::cout << "Data[" << i << "]==" << L.data[i] << "\n";
    }
    std::cout << "打印结束！\n";
}
```

下面是判空与获取长度函数，只需要获取顺序表`length`变量的值即可。

```c++
bool ListEmpty(const SqList &L) {
    return L.length == 0;
}

int ListLength(const SqList &L) {
    return L.length;
}
```

`GetElem`函数获取顺序表中第i个元素，这里的i是从1开始的，因此需要首先检测要求获取的值是否在范围内，小于1以及大于顺序表长度的值都是不允许的。如果查找失败则返回`false`，查找成功则返回`true`并且将查找到的值用e返回。

```c++
bool GetElem(const SqList &L, int i, int &e) {
    if (i < 1 || i > L.length) {
        return false;
    }
    e = L.data[i - 1];
    return true;
}
```

`LocateList`函数获取表中第一次出现e元素的位置，返回值为元素e在表中的位序，如果没找到则返回`0`。

```c++
int LocateElem(const SqList &L, int e) {
    for (int i = 0; i < L.length; ++i) {
        if (L.data[i] == e)
            return i + 1; // 返回位序
    }
    return 0; // 未找到返回0
}
```

`PriorElem`和`NextElem`函数在顺序表中查找元素e，若找到元素e且它有前一个或后一个元素，则用`pre_e`或`next_e`返回其相邻的上一个元素或下一个元素并且返回值为`true`，否则返回值为`false`并且`pre_e`和`next_e`不代表任何值。

```c++
bool PriorElem(const SqList &L, int cur_e, int &pre_e) {
    for (int i = 1; i < L.length; ++i) {
        if (L.data[i] == cur_e) {
            pre_e = L.data[i - 1];
            return true;
        }
    }
    return false;
}

bool NextElem(const SqList &L, int cur_e, int &next_e) {
    for (int i = 0; i < L.length - 1; ++i) {
        if (L.data[i] == cur_e) {
            next_e = L.data[i + 1];
            return true;
        }
    }
    return false;
}
```
`ListInsert`与`ListDelete`分别用于向顺序表插入元素和删除元素，需要注意的是，由于顺序表中元素的逻辑顺序和物理顺序保持一致，因此在进行插入操作时，需要将被插入位置后面的所有元素全部后移；在进行删除操作时，需要将被删除元素后面的的全部元素向前移动一位。移动操作的时间复杂度为$O(n)$。

```c++
bool ListInsert(SqList &L, int i, int e) {
    if (i < 1 || i > L.length + 1 || L.length >= MaxSize)
        return false;
    
    for (int j = L.length; j >= i; --j) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

bool ListDelete(SqList &L, int i, int &e) {
    if (i < 1 || i > L.length) {
        return false;
    }
    e = L.data[i - 1];
    for (int j = i; j < L.length; ++j) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}
```

`ListTraverse`函数用于使用指定的函数访问顺序表的各元素。

```c++
void ListTraverse(const SqList &L, void (*visit)(int)) {
    for (int i = 0; i < L.length; ++i) {
        visit(L.data[i]);
    }
}
```

例如有个简单的函数`visit`

```c++
void visit(int a){
    std::cout<<a<<std::endl;
}
```

可通过下面的方式调用`visit`函数

```c++
ListTraverse(L,visit);
```

`LocateChangeElem`与`GetChangeElem`分别是两种改元素值的方式，代码比较简单，先定位后修改，代码如下。

```c++
bool LocateChangeElem(SqList &L, int e, int em) {
    int bitOrder = LocateElem(L, e);
    if (bitOrder != 0) {
        L.data[bitOrder - 1] = em;
        return true;
    }
    return false;
}

bool GetChangeElem(SqList &L, int i, int em) {
    if (i < 0 || i >= L.length) return false;
    L.data[i] = em;
    return true;
}
```

##### 动态分配

相较于静态分配，动态分配顺序表的实现要稍显复杂，顺序表的数据结构如下：

```c++
class SeqList {
public:
    int *data; // 指示动态分配数组的指针
    int MaxSize; // 顺序表的最大容量
    int length; // 顺序表当前的长度

    SeqList() : data(new int[InitSize]), MaxSize(InitSize), length(0) {}
    ~SeqList() {
        delete[] data;
    }
};
```





### （二）链式存储





## 三、线性表的应用